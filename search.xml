<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>关于GitLab CI/CD</title>
      <link href="/2018/09/17/%E5%85%B3%E4%BA%8EGitLab-CICD/"/>
      <url>/2018/09/17/%E5%85%B3%E4%BA%8EGitLab-CICD/</url>
      <content type="html"><![CDATA[<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><blockquote><p>持续集成(Continuous Integration,简称CI)，指频繁将代码集成到主干。</p></blockquote><ul><li><p>目的：</p><p>  更快速地发布更新，让产品快速迭代，同时还能保持高质量，提高开发效率。</p></li><li><p>核心措施：</p><p>  代码集成到主干前，必须通过自动化测试。只要有测试用例不通过，就不能集成。</p></li><li><p>组成：</p><ul><li>一个自动构建的过程，包括自动编译、分发、部署和测试等；</li><li>一个代码存储库，即需要版本控制来保障代码的可维护性，同时作为构建过程的素材库；</li><li>一个持续集成服务器</li></ul></li></ul><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h2><blockquote><p>持续交付(Continuous Delivery)，指频繁地将软件的新版本交付给质量团队或用户，以供评审。如果评审通过，代码就进入生产阶段。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p></blockquote><h2 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h2><blockquote><p>持续部署(Continuous Deployment)，是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。<br>与<code>持续交付</code>的区别在于：部署到生产环境的过程是否自动化(<code>持续交付</code>需要手动部署到生产环境)。</p></blockquote><h2 id="Gitlab-CI-CD"><a href="#Gitlab-CI-CD" class="headerlink" title="Gitlab CI/CD"></a>Gitlab CI/CD</h2><blockquote><p>GitLab CI是GitLab提供的持续集成服务，只要在仓库根目录创建一个.gitlab.yml文件(定义GitLab runner要做哪些操作)，并为该项目指派一个Runner，当有Merge Request或push的时候就会触发build.</p></blockquote><ul><li><p>.gitlab-ci.yml文件</p><p>  <code>.gitlab-ci.yml</code>是用来配置CI在我们的项目中做些什么工作。位于项目的根目录。</p><p>  任何的push操作，GitLab都会寻找<code>.gitlab-ci.yml</code>文件，并对此次commit开始jobs，jobs的内容来源于<code>.gitlab-ci.yml</code>文件。</p></li><li><p>GitLab  Runner </p><p>  <code>GitLab Runner</code>是<code>.gitlab-ci.yml</code>脚本的运行器，在GitLab中，Runners将会运行你在<code>.gitlab-ci.yml</code>中定义的jobs，Runner可以是虚拟机、VPS、裸机、docker容器，或者是容器。<code>GitLab Runner</code>不需要和<code>GitLab</code>安装在同一台机器上，但是考虑到<code>GitLab Runner</code>的资源消耗问题和安全问题， 也不建议这两者安装在同一台机器上。GitLab和Runners通过API通信，所以唯一的要求就是运行Runners的机器可以联网。</p><p>  <code>GitLab Runner</code>分为两种：</p><pre><code>- Shared Runners:可以运行所有开启`Allow shared runners`选项的项目- Specific Runners:只能被指定的项目使用</code></pre></li><li><p>Pipelines</p><p>  <code>Pipelines</code>是定义于<code>.gitlab-ci.yml</code>中的不同阶段的不同任务。一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。每个<code>Pipelines</code>包含有多个<code>Stages</code>,每个<code>Stages</code>包含有一个或多个<code>jobs</code>。每一次Merge Request或push都要经过流水线之后才可以合格出厂。而<code>.gitlab-ci.yml</code>正是定义了<code>Pipelines</code>有哪些<code>Stages</code>，每个<code>Stages</code>要做什么事。</p></li><li><p>Stages</p><p>  <code>Stages</code>表示构建阶段，可以在一次<code>Pipelines</code>中定义多个<code>Stages</code>.默认<code>Pipelines</code>有三个<code>Stages</code>：<code>build</code>、<code>test</code>、<code>deploy</code></p><ul><li><p>所有<code>Stages</code>会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始；</p></li><li><p>只有当所有<code>Stages</code>完成后，该构建任务<code>(Pipeline)</code>才会成功</p></li><li><p>如果任何一个<code>Stages</code>失败，那么后面的<code>Stages</code>不会执行，该构建任务<code>(Pipeline)</code>失败</p></li></ul></li><li><p>Jobs</p><p>  <code>Jobs</code>表示构建工作，表示某个<code>Stage</code>里面执行的工作。</p><p>  | 关键字 | 是否必须 | 描述 |<br>  | — | — | — |<br>  | script | 是 | 定义<code>Runner</code>需要执行的脚本或命令 |<br>  | extends | 否 | 定义此 job 将继承的配置条目 |<br>  | image | 否 | 需要使用的docker镜像 |<br>  | services | 否 | 定义了所需的docker服务 |<br>  | stage | 否 | 定义了<code>Job</code>的阶段，默认是<code>test</code> |<br>  | type | 否 | <code>stage</code>的别名，不赞成使用 |<br>  | vaiables | 否 | 在<code>job</code>级别上定义的变量 |<br>  | only | 否 | 定义那些git分支适合该<code>job</code> |<br>  | except | 否 | 定义了哪些git分支不适合该<code>job</code> |<br>  | tages | 否 | 定义了哪些runner适合该job(runner在创建时会要求用户输入标签名来代表该runner) |<br>  | allow_failure | 否 | 允许任务失败，但是如果失败，将不会改变提交状态 |<br>  | when | 否 | 定义<code>job</code>什么时候能被执行，可以是<code>on_success</code>,<code>on_failure</code>,<code>always</code>或者<code>manual</code> |<br>  | dependencies | 否 | 定义了该<code>job</code>依赖哪一个<code>job</code>，如果设置该项，你可以通过artifacts设置 |<br>  | arfifacts | 否 | |<br>  | cache | 否 | 定义需要被缓存的文件、文件夹列表 |<br>  | before_script | 否 | 覆盖在根元素上定义的<code>before_script</code> |<br>  | after_script | 否 | 覆盖在根元素上定义的<code>after_script</code> |<br>  | environment | 否 | 定义让job完成部署的环境名称 |<br>  | coverage| 否 | 定义代码覆盖率设置 |<br>  | retry | 否 | 定义<code>job</code>失败后的自动充重试次数 |</p><ul><li><p>script</p><p>  <code>script</code>是一段由<code>Runner</code>执行的shell脚本，例如：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">    script:</span> <span class="string">"bundle exec rspec"</span></span><br></pre></td></tr></table></figure><p>  这个参数也可以使用数组包含几条命令：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">    script:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">uname</span> <span class="bullet">-a</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他</p><ul><li><p>从8.0版本开始，GitLab 持续集成（CI）完全集成到GitLab中，且默认所有的项目开启。</p></li><li><p><a href="https://docs.gitlab.com/ee/ci/quick_start/README.html" target="_blank" rel="noopener">文档地址</a></p></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写UT遇到的坑和解决方法</title>
      <link href="/2018/07/01/%E5%86%99UT%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2018/07/01/%E5%86%99UT%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<hr><p><strong>问题场景：</strong> 发送短信验证码的接口，验证码是一个由Util工具类生成的随机数，业务层需要验证结果</p><p><strong>解决方案：</strong> 使用PowerMock</p><blockquote><p>PowerMock扩展了EasyMock和Mockito框架，增加对static、final、私有方法的支持。</p></blockquote><p><code>PowerMock</code>有两个重要的注解：</p><ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest({YourClassEgStaticMethod.class})</code></li></ul><p>如果你的测试用例没有使用注解<code>@PrepareForTest</code>,那么可以不用加注解<code>@RunWith(PowerMockRunner.class)</code>,反之亦然。当你需要使用PowerMock强大功能(Mock静态、final、私有方法等)的时候，就需要加注解<code>@PrepareForTest</code>.</p><p>当某个测试方法被注解<code>@PrepareForTest</code>标注以后，在运行测试用例时，会创建一个新的<code>org.powermock.core.classloader.MockClassLoader</code>实例，然后加载该测试用例使用到的类(系统类除外)</p><p><code>PowerMock</code>会根据你的mock要求，去修改写在注解<code>@PrepareForTest</code>里的class文件(当前测试类会自动加入注解中),以满足特殊的mock需求.例如:去除final方法的final标识,在静态方法的最前面加入自己的虚拟实现等。</p><p>如果需要mock的是系统类的final方法和静态方法,<code>PowerMock</code>不会直接修改系统类的class文件，而是修改调用系统类的class文件,以满足mock需求.</p><ul><li>验证静态方法</li></ul><p>PowerMockito.verifyStatic(); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerMockito.verifyStatic(Mockito.times(<span class="number">2</span>)); <span class="comment">//被调用两次</span></span><br></pre></td></tr></table></figure><p>Static.firstStaticMethod(param);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tatic.thirdStaticMethod(Mockito.anyInt()); <span class="comment">// 以任何整数值被调用</span></span><br></pre></td></tr></table></figure><p><strong>实际解决代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PowerMockRunnerDelegate</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="meta">@PowerMockIgnore</span>(&#123;<span class="string">"javax.net.*"</span>, <span class="string">"javax.security.*"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsVerificationCodeControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> ThirdClient thirdClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> SmsVerificationCodeDao smsVerificationCodeDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送短信验证码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@PrepareForTest</span>(RandomUtils.class) </span><br><span class="line">    <span class="comment">//当mock静态方法、final方法时，必须加注解`@PrepareForTest`和`@RunWith`。注解`@PrepareForTest`里写的类是静态方法/final方法所在的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendVerificationCodeSms</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String code = <span class="string">"000000"</span>;</span><br><span class="line">        String telephone = <span class="string">"136********"</span>;</span><br><span class="line"></span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        response.setErrcode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        PowerMockito.mockStatic(RandomUtils.class);</span><br><span class="line">        PowerMockito.when(RandomUtils.getCodeChars()).thenReturn(code.toCharArray());</span><br><span class="line">        BDDMockito.given(thirdClient.sendSmsVcode(telephone, code)).willReturn(kdCloudResponse);</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(post(<span class="string">"/send/vcode"</span>)</span><br><span class="line">                .param(<span class="string">"telephone"</span>, telephone))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"errcode"</span>).value(<span class="number">0</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"description"</span>).value(<span class="string">"ok"</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"data"</span>).isEmpty());</span><br><span class="line"></span><br><span class="line">        BDDMockito.verify(smsVerificationCodeDao).insert(any(), anyString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>问题场景：</strong> 当遇到方法返回值为void,但又需要对返回值进行值相等判断时</p><p><strong>解决方案：</strong> 使用<code>Mockito.doAnswer</code></p><p><strong>实际解决代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginWithNewUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String username = <span class="string">"test@qq.com"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    Mockito.doAnswer(invocation -&gt; &#123;</span><br><span class="line">        User user = (User) invocation.getArguments()[<span class="number">0</span>];</span><br><span class="line">        user.setId(<span class="string">"10000"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;).when(userDao).save(any(User.class));</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(post(<span class="string">"/user/login"</span>)</span><br><span class="line">            .param(<span class="string">"username"</span>, username)</span><br><span class="line">            .param(<span class="string">"password"</span>, password))</span><br><span class="line">            .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">            .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"errcode"</span>).value(<span class="number">0</span>))</span><br><span class="line">            .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"data.id"</span>).value(<span class="string">"10000"</span>));</span><br><span class="line"></span><br><span class="line">    BDDMockito.verify(kdUserDao).save(any());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拦截器HandlerInterceptorAdapter的使用</title>
      <link href="/2018/04/21/HandlerInterceptorAdapter%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/04/21/HandlerInterceptorAdapter%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="拦截器-HandlerInterceptorAdapter的使用"><a href="#拦截器-HandlerInterceptorAdapter的使用" class="headerlink" title="拦截器 - HandlerInterceptorAdapter的使用"></a>拦截器 - HandlerInterceptorAdapter的使用</h3><blockquote><p>Spring为我们提供了<strong>org.springframework.web.servlet.handler.HandlerInterceptorAdapter</strong> 这个适配器，继承此类，可以实现自己的拦截器</p></blockquote><ul><li><strong>preHandle</strong> ：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如我们上一章的Controller实现）。返回值：true表示继续流程（如调用下一个拦截器或处理器）；  false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</li></ul><ul><li><p><strong>postHandle</strong> ：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</p></li><li><p><strong>afterCompletion</strong>：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。</p><p>​</p></li></ul><p><em>为何不使用 实现HandlerInterceptor接口的方法 来实现</em></p><p>有时候我们可能只需要实现三个回调方法中的某一个，如果实现HandlerInterceptor接口的话，三个方法必须实现，不管你需不需要，此时spring提供了一个HandlerInterceptorAdapter适配器（一种适配器设计模式的实现），允许我们只实现需要的回调方法。</p>]]></content>
      
      
        <tags>
            
            <tag> HandlerInterceptorAdapter </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jmeter</title>
      <link href="/2018/03/20/Jmeter/"/>
      <url>/2018/03/20/Jmeter/</url>
      <content type="html"><![CDATA[<h1 id="Jmeter-测试相关"><a href="#Jmeter-测试相关" class="headerlink" title="Jmeter 测试相关"></a>Jmeter 测试相关</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>一个性能测试请求负载是基于一个线程组完成的。一个测试计划必须有一个线程组。</p><p>JMeter中，每个测试计划至少需要包含一个线程组，当然也可以在一个计划中创建多个线程组。</p><p>在测试计划下面，多个线程是并行执行的，也就是说这些线程组是同时被初始化并同时执行线程组下的Sampler的。</p><p>线程组主要包括三个参数：线程数、准备时长(Ramp-Up Period(in seconds))、循环次数。</p><p><code>线程数</code>：虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数这里就设置多少个线程数。</p><p><code>准备时长</code>：设置的虚拟用户数需要多长时间全部启动。如果线程数为20，准备时长为10，那么需要10秒钟启动20个线程，也就是每秒启动2个线程。</p><p><code>循环次数</code>：每个线程发送请求的次数。如果线程数为20，循环次数为100，那么每个线程发送100次请求。总请求数为20*100=2000。如果勾选了“永远”，那么所有线程会一直发送请求，直到选择停止运行脚本。</p><h2 id="JmeterPlugin-说明"><a href="#JmeterPlugin-说明" class="headerlink" title="JmeterPlugin 说明"></a>JmeterPlugin 说明</h2><p><strong>Ramp-up Period(in seconds):</strong></p><ol><li>决定多长时间启动所有线程。如果使用10个线程，ramp-up period是100秒，那么JMeter用100秒使所有10个线程启动并运行。每个线程会在上一个线程启动后10秒(100/10)启动。</li></ol><p>Ramp=up需要充足长以避免在启动测试时有一个太大的工作负载，并且要充足小以至于最后一个线程在第一个完成前启动。</p><ol start="2"><li><p>用于告知JMeter 要在多长时间内建立全部的线程。默认值是0。如果未指定ramp-up period ，也就是说ramp-up period 为零， JMeter 将立即建立所有线程。假设ramp-up period 设置成T 秒， 全部线程数设置成N个， JMeter 将每隔T/N秒建立一个线程。</p></li><li><p>Ramp-Up Period(in-seconds)代表隔多长时间执行，0代表同时并发</p></li></ol><h3 id="Over-Time"><a href="#Over-Time" class="headerlink" title="Over Time"></a>Over Time</h3><p><code>Response Times Over Time</code>：响应时间变化曲线。X轴表示的是系统运行的时刻，Y轴表示的是响应时间，F(X,Y)表示系统随着时间的推移，系统的响应时间的变化，可以看出响应时间稳定性。</p><p><code>Response Time Percentiles Over Time</code>: 响应时间百分比，X轴表示的是百分比，Y轴表示的是响应时间，F(X,Y)表示低于某个百分比的响应时间</p><p><code>Active Threads Over Time</code>：随着时间推移活跃线程数， X轴表示访问的时刻，Y轴表示活动线程数，F(X,Y)表示某个时刻的活动线程数</p><p><code>Bytes Throughput Over Time</code>：随着时间推移每秒接收和请求字节数变化趋势图，蓝色为每秒发送字节数，黄色为每秒接收字节数</p><p><code>Latencies Over Time</code>：每秒钟的响应等待时间， 表明Jmeter测试期间，随着时间的推移系统的响应等待时间的变化，也是系统随着时间推移，系统效率的变化。</p><p><code>Connect Time Over Time</code>：请求连接建立的时间</p><hr><h3 id="Throughput"><a href="#Throughput" class="headerlink" title="Throughput"></a>Throughput</h3><p><code>Hits per second</code>：每秒点击率</p><p><code>Codes per second</code>：每秒状态码数量</p><p><code>Transactions per second</code>：每秒事务量</p><p><code>Response Times vs Threads</code>：响应时间用户数， X轴表示的是活动线程数，也就是并发访问的用户数，Y轴表示的是响应时间，F(X,Y)表示在某种并发量的情况下，系统的响应时间是多少。</p><p><code>Latency Vs Request</code>: 延迟时间点请求的 成功/失败 数</p><hr><h3 id="Response-Times"><a href="#Response-Times" class="headerlink" title="Response Times"></a>Response Times</h3><p><code>Response Time Percentiles</code>：响应时间百分比</p><p><code>Response Time Overview</code>：响应时间分布</p><p><code>Time Vs Threads</code>: 测试过程中的线程数时续图</p><p><code>Response Time Distribution</code>: 响应时间分布</p><h2 id="JmeterPlugin-参数说明"><a href="#JmeterPlugin-参数说明" class="headerlink" title="JmeterPlugin 参数说明"></a>JmeterPlugin 参数说明</h2><p><code>Samples</code>：运行的线程数（也可理解为请求数）</p><p><code>Average</code>：平均响应时间，单位：ms</p><p><code>Median</code>：中位数，即50%用户的响应时间</p><p><code>90%Line</code>：90%用户的响应时间</p><p><code>95%Line</code>：95%用户的相应时间</p><p><code>99%Line</code>：99%用户的响应时间</p><p><code>Min</code>：最小响应时间</p><p><code>Max</code>：最大响应时间</p><p><code>Error</code>：本次测试中出现错误的请求的数量/请求的总数</p><p><code>Throughput</code>：吞吐量-每秒完成的请求数</p><p><code>Received KB/sec</code>：每秒从服务器端接收到的数据量</p><p><code>Sent KB/sec</code>：发送的千字节每秒的吞吐量测试</p><p><code>KB/sec</code>：每秒从服务器端接收到的数据量</p><p><code>Elapsed time</code>：经过的时间(= Sample time = Load time = Response time )<br>这个时间是我们测试常用的时间，也是整个请求的消耗时间，从发送到接收完成全程消耗的时间</p><p><code>Latency time</code>：延迟时间。不常用，表示请求发送到刚开始接收响应时，这个时间&lt;Elapsed time</p><p><code>Connection time</code>：不常用，请求连接建立的时间，这个时间 &lt; Latency time &lt; Elapsed time</p>]]></content>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSR-303校验</title>
      <link href="/2017/12/20/JSR-303%E6%A0%A1%E9%AA%8C/"/>
      <url>/2017/12/20/JSR-303%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h3 id="JSR-303校验"><a href="#JSR-303校验" class="headerlink" title="JSR-303校验"></a>JSR-303校验</h3><blockquote><p>JSR 303是Java EE 6中的一个数据校验规范，叫做Bean Validation，用于对Java Bean中的字段的值进行验证，官方参考实现是Hibernate Validator(validation-api是JSR-303规范的标准接口，Hibernate-validator则是这套接口的一个实现)。此实现与Hibernate ORM没有任何关系。</p></blockquote><h4 id="完成Java-Bean的验证的步骤："><a href="#完成Java-Bean的验证的步骤：" class="headerlink" title="完成Java Bean的验证的步骤："></a>完成Java Bean的验证的步骤：</h4><ol><li>约束注解的定义</li><li>约束验证规则（约束验证器）</li><li>约束注解的声明</li></ol><h4 id="约束的定义"><a href="#约束的定义" class="headerlink" title="约束的定义"></a>约束的定义</h4><p>一个constraint通常由annotation和相应的constraint validator组成，他们是一对多的关系。</p><p>当需要更加复杂的constraint，Bean Validation提供扩展constraint的机制。可以通过两种方法去实现：</p><ul><li><p>组合现有的constraint来生成一个更复杂的constraint</p></li><li><p>开发一个全新的constraint</p><p>定义一个新的Constraint注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD,ElementType.METHOD,ElementType.PARAMETER&#125;) <span class="comment">//约束注解应用的目标元素类型</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">//约束注解应用的时机</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;MobilePhoneValidator.class&#125;) <span class="comment">//与约束注解关联的验证器</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MobileNumber &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "电话号码格式不正确"</span>;     <span class="comment">//约束注解验证时的输出消息</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;     <span class="comment">//约束注解在验证时所属的组别</span></span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;; <span class="comment">//约束注解的有效负载</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Constraint注解标注表明我们定义了一个用于限制的注解，validatedBy属性用于指定我们定义的当前限制类型需要被哪个ConstraintValidator进行校验。</p><p>在定义自己的限制类型的注解时，有三个属性是必须定义的，<strong>message</strong>、<strong>groups</strong>、<strong>payload</strong> 属性</p><p>对应的限制类型校验类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobilePhoneValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">MobileNumber</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pattern mobilePhonePattern = Pattern.compile(<span class="string">"1([\\d]&#123;10&#125;)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(MobileNumber constraintAnnotation)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( value == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mobilePhonePattern.matcher(value).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制类型校验类必须实现接口java.validation.ConstraintValidator，并实现它的initialize和isValid方法。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes the validator in preparation for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #isValid(Object, ConstraintValidatorContext)&#125; calls.</span></span><br><span class="line"><span class="comment"> * The constraint annotation for a given constraint declaration</span></span><br><span class="line"><span class="comment"> * is passed.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * This method is guaranteed to be called before any use of this instance for</span></span><br><span class="line"><span class="comment"> * validation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> constraintAnnotation annotation instance for a given constraint declaration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(A constraintAnnotation)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements the validation logic.</span></span><br><span class="line"><span class="comment"> * The state of &#123;<span class="doctag">@code</span> value&#125; must not be altered.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * This method can be accessed concurrently, thread-safety must be ensured</span></span><br><span class="line"><span class="comment"> * by the implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value object to validate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context context in which the constraint is evaluated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> false&#125; if &#123;<span class="doctag">@code</span> value&#125; does not pass the constraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(T value, ConstraintValidatorContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConstraintValidator是使用了泛型的。它一共需要指定两种类型，第一个类型是对应的initialize方法的参数类型，第二个类型是对应的isValue方法的第一个参数类型。</p><p>从上面两个方法可以看出，isValue方法用于进行校验的。有时候我们在校验的过程中是需要取当前的限制类型的属性来进行校验的，比如我们在对@Min限制类型进行校验的时候我们是需要通过其value属性获取到当前校验类型定义的最小值的，我们可以看到isValid方法无法获取到当前的限制类型Money。这个时候initialize方法的作用就出来了。我们知道initialize方法是可以获取到当前的限制类型的，所以当我们在校验某种限制类型时需要获取当前限制类型的某种属性的时候，我们可以给当前的ConstraintValidator定义对应的属性，然后在initialize方法中给该属性赋值，接下来我们就可以在isValid方法中使用其对应的属性了。针对于这种情况我们来看一个代码示例，现在假设我要定义自己的@Min限制类型和对应的MinValidator校验器，那么我可以如下定义：</p><p><strong>Min限制类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD&#125;)  </span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  </span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy=MinValidator.class)  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Min &#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;  </span><br><span class="line">     </span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span></span>;  </span><br><span class="line">     </span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;  </span><br><span class="line">     </span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MinValidator校验器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">Min</span>, <span class="title">Integer</span>&gt; </span>&#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minValue;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Min min)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">       <span class="comment">//把Min限制类型的属性value赋值给当前ConstraintValidator的成员变量minValue  </span></span><br><span class="line">       minValue = min.value();  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext arg1)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">       <span class="comment">//在这里我们就可以通过当前ConstraintValidator的成员变量minValue访问到当前限制类型Min的value属性了  </span></span><br><span class="line">       <span class="keyword">return</span> value &gt;= minValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>继续来说一下<strong>ConstraintValidator泛型的第二个类型</strong>，我们已经知道它的第二个类型是<strong>对应的isValid的方法的第一个参数</strong>，从我给的参数名称value来看也可以知道isValid方法的第一个参数正是对应的当前需要校验的数据的值，而它的类型也正是对应的我们需要校验的数据的数据类型。这两者的数据类型必须保持一致，否则Spring会提示找不到对应数据类型的ConstraintValidator。建立了自己的限制类型及其对应的ConstraintValidator后，其用法跟标准的JSR-303限制类型是一样的。</p><hr><p>附:</p><p> <strong>JSR 303一些验证约束 </strong></p><p><code>Bean Validation中内置的constraint</code></p><table><thead><tr><th>Constraint(约束)</th><th>说明</th></tr></thead><tbody><tr><td>@Null</td><td>被对象是否为null</td></tr><tr><td>@NotNull</td><td>被对象是否不为不为null</td></tr><tr><td>@NotBlank</td><td>检查约束字符串是不是Null还有被trim的长度是否大于0,只对字符串,且会去掉前后空格</td></tr><tr><td>@AssertTrue</td><td>被Boolean对象是否为true</td></tr><tr><td>@AssertFalse</td><td>被Boolean对象是否为false</td></tr><tr><td>@Min(value)</td><td>被注释的元素必须是一个数字，其值必须大于等于value</td></tr><tr><td>@Max(value)</td><td>被注释的元素必须是一个数字，其值必须小于等于value</td></tr><tr><td>@DecimalMin(value)</td><td>被注释的元素必须是一个数字，其值必须大于等于value</td></tr><tr><td>@DecimalMax(value)</td><td>被注释的元素必须是一个数字，其值必须小于等于value</td></tr><tr><td>@Size(max,min)</td><td>被对象(Array,Collection,Map,String)的长度/集合大小是否在指定的范围内</td></tr><tr><td>@Digits(integer,fraction)</td><td>被注释的元素必须是一个数字，其值必须在可接收的范围内(integer指定整数精度，fraction指定小数精度)</td></tr><tr><td>@Past</td><td>被Date和Calendar对象是否在当前时间之前</td></tr><tr><td>@Future</td><td>被Date和Calendar对象是否在当前时间之后</td></tr><tr><td>@Pattern(value)</td><td>被注释的元素必须符合指定的正则表达式</td></tr><tr><td>@Valid</td><td>递归地对关联对象进行校验，如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个map，则对其中的值的部分进行校验</td></tr></tbody></table><p><code>Hibernate Validator附加的constraint</code></p><table><thead><tr><th>Constraint</th><th>说明</th></tr></thead><tbody><tr><td>@Email</td><td>被注释</td></tr><tr><td>@Length</td><td>被注释的字符串的大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>被注释的字符串必须非空</td></tr><tr><td>@Range(min,max)</td><td>被注释的元素必须在合适的范围内</td></tr><tr><td>@CreditCardNumber</td><td>信用卡验证</td></tr></tbody></table><p>附：</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-beanvalid/" target="_blank" rel="noopener">Bean Validation 技术规范特性概述</a></p><p><a href="https://my.oschina.net/u/726229/blog/310063" target="_blank" rel="noopener">SpringMVC介绍之Validation</a></p><p><a href="https://my.oschina.net/stategrace/blog/347278" target="_blank" rel="noopener">jsr303，jsr 349自定义注解验证实现</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/" target="_blank" rel="noopener">JSR 303 - Bean Validation 介绍及最佳实践</a></p>]]></content>
      
      
        <tags>
            
            <tag> 数据校验 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日期和时间使用技巧</title>
      <link href="/2017/12/10/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/12/10/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h4 id="以前"><a href="#以前" class="headerlink" title="以前"></a>以前</h4><p>使用 <strong>System.currentTimeMillis()</strong> 来返回1970年1月1日到今天的毫秒数。</p><p>或者使用 <strong>Date</strong> 类来操作日期。</p><p>当遇到加减月份、天数的时候，又需要用到 <strong>Calendar</strong> 。</p><p>当需要格式化日期的时候需要使用<strong>java.text.DateFormat</strong> 类。</p><p>再或者引入第三方 <strong>Joda-Time</strong> 这个专门处理日期时间的库。</p><h4 id="为什么我们需要新的Java日期-时间API"><a href="#为什么我们需要新的Java日期-时间API" class="headerlink" title="为什么我们需要新的Java日期/时间API"></a>为什么我们需要新的Java日期/时间API</h4><ol><li>Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义</li><li>java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计</li><li>对于时间、时间戳、格式化以及解析，并没有一些明确定义的类。对于格式化和解析的需求，我们有java.text.DateFormat抽象类，但通常情况下，SimpleDateFormat类被用于此类需求</li><li>所有的日期类都是可变的，因此他们都不是线程安全的，这是Java日期类最大的问题之一</li><li>日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li></ol><h4 id="JAVA8日期时间API"><a href="#JAVA8日期时间API" class="headerlink" title="JAVA8日期时间API"></a>JAVA8日期时间API</h4><p>Java 8中 java.util.Date 类新增了两个方法，分别是<strong>from(Instant instant)</strong>和<strong>toInstant()</strong>方法。</p><p>这两个方法使我们可以方便的实现将旧的日期类转换为新的日期类，具体思路都是通过Instant当中介，然后通过Instant来创建LocalDateTime（这个类可以很容易获取LocalDate和LocalTime），新的日期类转旧的也是如此，将新的先转成LocalDateTime，然后获取Instant，接着转成Date。</p><p><code>java.time包</code> 是在JDK8引入的，提供了用于日期、时间、实例和周期的主要API。所有的类都是<strong>线程安全</strong>的</p><ul><li>ZoneId：时区ID，用来确定Instant和LocalDateTime互相转换的规则</li><li>Instant：用来表示时间线上的一个点</li><li>LocalDate：表示没有时区的日期，LocalDate是不可变并且线程安全的</li><li>LocalTime：表示没有时区的时间，LocalTime是不可变并且线程安全的</li><li>LocalDateTime：表示没有时区的日期时间，LocalDateTime是不可变并且线程安全的</li><li>Clock：时钟，用于访问当前时刻、日期、时间，用到时区</li><li>Duration：用秒和纳秒表示时间的数量</li><li>Year：表示年份</li><li>Month：表示月份</li><li>YearMonth：表示年月</li><li>MonthDay：表示月日</li><li>DayOfWeek：存储星期的一天</li><li>DateTimeFormatter：在日期对象与字符串之间进行转换</li><li>ChronoUnit：计算出两个时间点之间的时间距离，可按多种时间单位计算</li><li>TemporalAdjuster：各种日期计算功能</li></ul><h4 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h4><blockquote><p>它代表的是时间戳</p></blockquote><h4 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h4><blockquote><p>LocalDate代表一个ISO格式(yyyy-MM-dd)的日期，如：2017-12-07，可以存储纪念日等日期。</p></blockquote><p>获取当前的日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">System.out.println(localDate);</span><br></pre></td></tr></table></figure><p>输出：2017-12-07</p><p>LocalDate可以指定特定的日期，调用of或parse方法返回该实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate.of(<span class="number">2017</span>, <span class="number">07</span>, <span class="number">20</span>);</span><br><span class="line">LocalDate.parse(<span class="string">"2017-07-20"</span>);</span><br></pre></td></tr></table></figure><p><strong>明天</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now().plusDays(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>减去一个月</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate prevMonth = LocalDate.now().minus(<span class="number">1</span>, ChronoUnit.MONTHS);</span><br></pre></td></tr></table></figure><p><strong>每周中的星期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayOfWeek thursday = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfWeek();</span><br></pre></td></tr></table></figure><p><strong>每月中的日</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> twenty = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfMonth();</span><br></pre></td></tr></table></figure><p><strong>是否是闰年</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> leapYear = LocalDate.now().isLeapYear();</span><br></pre></td></tr></table></figure><p><strong>日期之前</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> notBefore = LocalDate.parse(<span class="string">"2017-07-20"</span>).isBefore(LocalDate.parse(<span class="string">"2017-07-22"</span>));</span><br></pre></td></tr></table></figure><p><strong>日期之后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isAfter = LocalDate.parse(<span class="string">"2017-07-20"</span>).isAfter(LocalDate.parse(<span class="string">"2017-07-22"</span>));</span><br></pre></td></tr></table></figure><p><strong>日期相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isSame = LocalDate.parse(<span class="string">"2017-07-20"</span>).isAfter(LocalDate.parse(<span class="string">"2017-07-20"</span>));</span><br></pre></td></tr></table></figure><p><strong>获取这个月的第一天</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate first = LocalDate.now().with(TemporalAdjusters.firstDayOfMonth());</span><br></pre></td></tr></table></figure><p><strong>判断生日</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate birthday = LocalDate.of(<span class="number">2017</span>,<span class="number">12</span>,<span class="number">07</span>);</span><br><span class="line">MonthDay birthdayMd  = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.now());</span><br><span class="line"><span class="keyword">boolean</span> isBirthday = today.equals(birthdayMd)</span><br></pre></td></tr></table></figure><h4 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h4><blockquote><p>表示一个时间，而不是日期，如：20:16:34.963</p></blockquote><p><strong>现在的时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now = LocalTime.now();</span><br></pre></td></tr></table></figure><p><strong>字符串解析为LocalTime</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime nowTime = LocalTime.parse(<span class="string">"15:02"</span>);</span><br></pre></td></tr></table></figure><p><strong>使用of创建一个时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime nowTime = LocalTime.of(<span class="number">15</span>, <span class="number">02</span>);</span><br></pre></td></tr></table></figure><p><strong>使用字符串解析并添加一小时</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime nowTime = LocalTime.parse(<span class="string">"15:02"</span>).plus(<span class="number">1</span>, ChronoUnit.HOURS);</span><br></pre></td></tr></table></figure><p><strong>获取时间的小时、分钟、秒</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int hour = LocalTime.parse(&quot;15:02&quot;).getHour();</span><br><span class="line">int minute = LocalTime.parse(&quot;15:02&quot;).getMinute();</span><br><span class="line">int second = LocalTime.parse(&quot;15:02&quot;).getSecond()</span><br></pre></td></tr></table></figure><p><strong>判断时间前后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isBefore = LocalTime.parse(<span class="string">"15:02"</span>).isBefore(LocalTime.parse(<span class="string">"16:02"</span>));</span><br><span class="line"><span class="keyword">boolean</span> isAfter = LocalTime.parse(<span class="string">"15:02"</span>).isAfter(LocalTime.parse(<span class="string">"16:02"</span>));</span><br></pre></td></tr></table></figure><h4 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h4><blockquote><p>LocalDateTime是用来表示日期和时间的，不过还是没有偏移信息或者说时区。如：2017-12-07T20:17:04.199</p></blockquote><p><strong>获取当前的日期和时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br></pre></td></tr></table></figure><p><strong>使用静态方法和字符串创建LocalDateTime对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.of(<span class="number">2017</span>, Month.JULY, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">10</span>);</span><br><span class="line">LocalDateTime.parse(<span class="string">"2017-07-20T15:18:10"</span>);</span><br></pre></td></tr></table></figure><p><strong>日期增减</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime tomorrow = now.plusDays(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"明天的这个时间: "</span> + tomorrow);</span><br><span class="line">LocalDateTime minusTowHour = now.minusHours(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"两小时前: "</span> + minusTowHour);</span><br></pre></td></tr></table></figure><p><strong>该类也提供一系列的get方法来获取特定单位</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Month month = LocalDateTime.now().getMonth();</span><br></pre></td></tr></table></figure><p><strong>使用</strong>DateTimeFormatter<strong>的</strong>format<strong>方法将日期、时间格式化为字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">String dateString = dateTimeFormatter.format(LocalDate.now());</span><br><span class="line"></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">String dateString = dateTimeFormatter.format(LocalDateTime.now());</span><br></pre></td></tr></table></figure><h4 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h4><blockquote><p>日期周期，用于修改给定日期或获得的两个日期之间的区别</p></blockquote><p><strong>日期+5</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate initialDate = LocalDate.parse(<span class="string">"2017-07-20"</span>);</span><br><span class="line">LocalDate finalDate   = initialDate.plus(Period.ofDays(<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">"初始化日期: "</span> + initialDate);  <span class="comment">//2017-12-07</span></span><br><span class="line">System.out.println(<span class="string">"加日期之后: "</span> + finalDate);    <span class="comment">//2017-12-10</span></span><br></pre></td></tr></table></figure><p>周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> between = ChronoUnit.DAYS.between(initialDate, finalDate);</span><br><span class="line">System.out.println(<span class="string">"差距天数: "</span> + between);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate initialDate = LocalDate.of(<span class="number">2017</span>,<span class="number">7</span>,<span class="number">20</span>);</span><br><span class="line">LocalDate finalDate   = LocalDate.of(<span class="number">2016</span>,<span class="number">7</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(finalDate.until(initialDate, ChronoUnit.DAYS));  <span class="comment">//364</span></span><br></pre></td></tr></table></figure><h4 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h4><blockquote><p> 这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.now();  <span class="comment">//2017-12-07T21:47:52.495+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><h4 id="OffsetDateTime"><a href="#OffsetDateTime" class="headerlink" title="OffsetDateTime"></a>OffsetDateTime</h4><blockquote><p>实际上包含了LocalDateTime与ZoneOffset。它用来表示一个包含格林威治时间偏移量（+/-小时：分，比如+06:00或者 -08：00）的完整的日期（年月日）及时间（时分秒，纳秒）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2016</span>, Month.JULY, <span class="number">14</span>, <span class="number">14</span>,<span class="number">20</span>);</span><br><span class="line">ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">"+8"</span>);</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</span><br><span class="line">System.out.println(offsetDateTime); <span class="comment">//2016-07-14T14:20+08:00</span></span><br></pre></td></tr></table></figure><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p><strong>Date和Instant互相转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = Instant.now();<span class="comment">//2017-12-07T11:27:07.005Z</span></span><br><span class="line">Date date = Date.from(instant);<span class="comment">//Thu Dec 07 19:27:07 CST 2017</span></span><br><span class="line">Instant instant1 = date.toInstant();<span class="comment">//2017-12-07T11:27:07.005Z</span></span><br></pre></td></tr></table></figure><p><strong>Date转LocalDateTime</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();<span class="comment">//Thu Dec 07 19:33:20 CST 2017</span></span><br><span class="line">Instant instant = date.toInstant();<span class="comment">//2017-12-07T11:33:20.218Z</span></span><br><span class="line">ZoneId zoneId = ZoneId.systemDefault();<span class="comment">//Asia/Shanghai</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);<span class="comment">//2017-12-07T19:33:20.218</span></span><br></pre></td></tr></table></figure><p><strong>LocalDateTime转Date</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();<span class="comment">//2017-12-07T19:47:49.385</span></span><br><span class="line">ZonedDateTime zonedDateTime = localDateTime.atZone(ZoneId.systemDefault()); <span class="comment">//2017-12-07T19:47:49.385+08:00[Asia/Shanghai]</span></span><br><span class="line">Instant instant = zonedDateTime.toInstant();<span class="comment">//2017-12-07T11:47:49.385Z</span></span><br><span class="line">Date date = Date.from(instant);<span class="comment">//Thu Dec 07 19:47:49 CST 2017</span></span><br></pre></td></tr></table></figure><p><strong>LocalDate转Date</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();<span class="comment">//2017-12-07</span></span><br><span class="line">LocalDateTime localDateTime = localDate.atStartOfDay();<span class="comment">//2017-12-07T00:00</span></span><br><span class="line">ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">ZonedDateTime zonedDateTime = localDateTime.atZone(zone);<span class="comment">//2017-12-07T00:00+08:00[Asia/Shanghai]</span></span><br><span class="line">Date date = Date.from(zonedDateTime.toInstant());<span class="comment">//Thu Dec 07 00:00:00 CST 2017</span></span><br></pre></td></tr></table></figure><p><strong>Date转LocalDate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();<span class="comment">//Thu Dec 07 19:33:20 CST 2017</span></span><br><span class="line">Instant instant = date.toInstant();<span class="comment">//2017-12-07T11:33:20.218Z</span></span><br><span class="line">ZoneId zoneId = ZoneId.systemDefault();<span class="comment">//Asia/Shanghai</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);<span class="comment">//2017-12-07T19:33:20.218</span></span><br><span class="line">LocalDate localDate = localDateTime.toLocalDate(); <span class="comment">//2017-12-07</span></span><br></pre></td></tr></table></figure><p><strong>Date转LocalTime</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();<span class="comment">//Thu Dec 07 19:33:20 CST 2017</span></span><br><span class="line">Instant instant = date.toInstant();<span class="comment">//2017-12-07T11:33:20.218Z</span></span><br><span class="line">ZoneId zoneId = ZoneId.systemDefault();<span class="comment">//Asia/Shanghai</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);<span class="comment">//2017-12-07T19:33:20.218</span></span><br><span class="line">LocalTime localTime = localDateTime.toLocalTime();<span class="comment">//19:33:20.218</span></span><br></pre></td></tr></table></figure><p><strong>LocalTime转Date</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();<span class="comment">//21:41:29.072</span></span><br><span class="line">LocalDate localDate = LocalDate.now();<span class="comment">//2017-12-07</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);<span class="comment">//2017-12-07T21:41:29.072</span></span><br><span class="line">ZoneId zoneId = ZoneId.systemDefault();  <span class="comment">//Asia/Shanghai</span></span><br><span class="line">Instant instant = localDateTime.atZone(zoneId).toInstant();<span class="comment">//2017-12-07T13:41:29.072Z</span></span><br><span class="line">Date date = Date.from(instant);<span class="comment">//Thu Dec 07 21:41:29 CST 2017</span></span><br></pre></td></tr></table></figure><h4 id="java-util-Date到新库类的转换"><a href="#java-util-Date到新库类的转换" class="headerlink" title="java.util.Date到新库类的转换"></a>java.util.Date到新库类的转换</h4><p>转换可通过下面的方法进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date.toInstant()</span><br><span class="line">Date.from(Instant)</span><br><span class="line">Calendar.toInstant()</span><br></pre></td></tr></table></figure><h4 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h4><blockquote><p>Clock提供了对当前时间和日期的访问功能。Clock是对当前时区敏感的，并可用于替代System.currentTimeMillis()方法来获取当前的毫秒时间。当前时间线上的时刻可以用Instance类来表示。Instance也能够用于创建原先的java.util.Date对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Clock clock=Clock.systemUTC();<span class="comment">//获取格林尼治时间</span></span><br><span class="line">System.out.println(clock.instant());<span class="comment">//获取Instant类型数据，后面会讲到</span></span><br><span class="line">System.out.println(clock.millis());<span class="comment">//获取标准毫秒数</span></span><br></pre></td></tr></table></figure><h4 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h4><blockquote><p>在日期对象与字符串之间进行转换</p></blockquote><p><strong>DateTimeFormatter与SimpleDateFormat的区别</strong></p><ul><li>Java8的DateTimeFormatter也是线程安全的，而SimpleDateFormat并不是线程安全</li></ul><p><strong>获取DateTimeFormatter对象的三种方式</strong></p><ul><li>直接使用静态常量创建DateTimeFormatter格式器</li><li>使用代码不同风格的枚举值来创建DateTimeFormatter格式器</li><li>根据模式字符串来创建DateTimeFormatter格式器</li></ul><p><strong>DateTimeFormatter完成格式化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter[] formatters = <span class="keyword">new</span> DateTimeFormatter[]&#123;</span><br><span class="line">  <span class="comment">//直接使用常量创建DateTimeFormatter格式器</span></span><br><span class="line">  DateTimeFormatter.ISO_LOCAL_DATE,   <span class="comment">//2017-12-08</span></span><br><span class="line">  DateTimeFormatter.ISO_LOCAL_TIME,   <span class="comment">//16:48:56.944</span></span><br><span class="line">  DateTimeFormatter.ISO_LOCAL_DATE_TIME,  <span class="comment">//2017-12-08T16:48:56.944</span></span><br><span class="line">  <span class="comment">//使用本地化的不同风格来创建DateTimeFormatter格式器</span></span><br><span class="line">  DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG),    <span class="comment">//下午04时48分56秒</span></span><br><span class="line">  DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL),    <span class="comment">//2017年12月8日 星期五</span></span><br><span class="line">  DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.MEDIUM),    <span class="comment">//2017年12月8日 星期五 16:48:56</span></span><br><span class="line">  <span class="comment">// 根据模式字符串来创建DateTimeFormatter格式器</span></span><br><span class="line">  DateTimeFormatter.ofPattern(<span class="string">"GyyyyMMMdd HH:mm:ss"</span>)  <span class="comment">//公元2017十二月08 16:53:46</span></span><br><span class="line">&#125;;</span><br><span class="line">LocalDateTime date = LocalDateTime.now();</span><br><span class="line"><span class="comment">// 依次使用不同的格式器对LocalDateTime进行格式化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; formatters.length ; i++)</span><br><span class="line">&#123;</span><br><span class="line">  System.out.println(date.format(formatters[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DateTimeFormatter解析字符串</strong></p><ul><li>根据需求的日期时间字符串，定义解析所用的格式器</li><li>执行解析XX.parse(string, fomatter)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个任意格式的日期时间字符串</span></span><br><span class="line">String str1 = <span class="string">"2017==12==07 17时00分00秒"</span>;</span><br><span class="line"><span class="comment">// 根据需要解析的日期、时间字符串定义解析所用的格式器</span></span><br><span class="line">DateTimeFormatter fomatter1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy==MM==dd HH时mm分ss秒"</span>);</span><br><span class="line"><span class="comment">// 执行解析</span></span><br><span class="line">LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1); <span class="comment">//2017-12-07T17:00</span></span><br></pre></td></tr></table></figure><h4 id="ChronoUnit"><a href="#ChronoUnit" class="headerlink" title="ChronoUnit"></a>ChronoUnit</h4><blockquote><p>计算出两个时间点之间的时间距离，可按多种时间单位计算</p></blockquote><h4 id="TemporalAdjuster"><a href="#TemporalAdjuster" class="headerlink" title="TemporalAdjuster"></a>TemporalAdjuster</h4><blockquote><p>各种日期计算功能</p></blockquote><p><strong>从Year获取LocalDate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Year year = Year.now();</span><br><span class="line">LocalDate localDate = year.atDay(<span class="number">59</span>);  <span class="comment">//2017-02-28</span></span><br></pre></td></tr></table></figure><p><strong>把LocalTime关联到一个LocalDate得到一个LocalDateTime</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDateTime localDateTime = localTime.atDate(localDate);<span class="comment">//2017-02-28T20:44:40.822</span></span><br></pre></td></tr></table></figure><p><strong>从Year获取YearMonth</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YearMonth yearMonth = year.atMonth(<span class="number">2</span>);<span class="comment">//2017-02</span></span><br></pre></td></tr></table></figure><p><strong>YearMonth指定日得到LocalDate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate1 = yearMonth.atDay(<span class="number">28</span>);<span class="comment">//2017-02-28</span></span><br></pre></td></tr></table></figure><p><strong>解析字符串形式的日期时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy MM dd"</span>);</span><br><span class="line">TemporalAccessor temporalAccessor = formatter.parse(<span class="string">"2013 01 15"</span>);</span><br><span class="line">LocalDate localDate = LocalDate.from(temporalAccessor);</span><br><span class="line">System.out.println(<span class="string">"TemporalAccessor :"</span> +localDate); <span class="comment">//TemporalAccessor :2013-01-15</span></span><br></pre></td></tr></table></figure><p><strong>计算某月的第一个星期一的日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TemporalAdjuster temporalAdjuster = TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY);</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalDate localDate1 = localDate.with(temporalAdjuster);</span><br><span class="line">System.out.println(localDate1);<span class="comment">//2017-12-04(12月的第一个周一)</span></span><br></pre></td></tr></table></figure><p><strong>计算某月第一天的日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TemporalAdjuster temporalAdjuster = TemporalAdjusters.firstDayOfMonth();</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalDate localDate1 = localDate.with(temporalAdjuster);</span><br><span class="line">System.out.println(localDate1);<span class="comment">//2017-12-01</span></span><br></pre></td></tr></table></figure><p><strong>计算LocalDate的下一个星期一的日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.MONDAY);</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalDate localDate1 = localDate.with(temporalAdjuster);</span><br><span class="line">System.out.println(localDate1);<span class="comment">//2017-12-11</span></span><br></pre></td></tr></table></figure><p>该包的API提供了大量相关的方法，这些方法一般有一致的方法前缀：</p><ul><li>of：静态工厂方法。</li><li>parse：静态工厂方法，关注于解析。</li><li>get：获取某些东西的值。</li><li>is：检查某些东西的是否是true。</li><li>with：不可变的setter等价物。</li><li>plus：加一些量到某个对象。</li><li>minus：从某个对象减去一些量。</li><li>to：转换到另一个类型。</li><li>at：把这个对象与另一个对象组合起来，例如：<code>date.atTime(time)</code>。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 日期处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>统一异常处理</title>
      <link href="/2017/11/01/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2017/11/01/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="关于全局异常处理"><a href="#关于全局异常处理" class="headerlink" title="关于全局异常处理"></a>关于全局异常处理</h4><blockquote><p>程序中存在一些诸如用户操作不当或者程序的bug，有大量需要处理的异常。而有些异常是不能直接抛给用户的，而是需要处理通过一些弹窗等提示信息的方法告知用户。</p><p>而这就需要在程序中有一个机制，去处理这些异常，将程序的异常转换为用户可读的异常</p></blockquote><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><ul><li>用户输入了非法数据</li><li>程序错误引起</li><li>物理错误引起</li></ul><h5 id="没有异常处理"><a href="#没有异常处理" class="headerlink" title="没有异常处理"></a>没有异常处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"system exception"</span>,<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求接口直接把异常抛出（在默认情况下，Spring MVC处理Web请求时如果发现存在没有应用代码捕获的异常，那么会返回HTTP 500（Internal Server Error）错误。），如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="number">1514280270178</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Internal Server Error"</span>,</span><br><span class="line">    <span class="attr">"exception"</span>: <span class="string">"com.test.SystemException"</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"system exception"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>自定义一个异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SystemException</span><span class="params">(String message, Integer code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>定义当前Controller异常处理</p><p><code>@ExceptionHandler</code>可以使用在任何用<code>@Controller</code>注解修饰的类中，设置出现某种异常的时候执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"system exception"</span>,<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">expHandler</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> SystemException)&#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">"Error code:%s,Message:%s"</span>, ((SystemException) e).getCode(), e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求接口结果按照预期打印：Error code:500,Message:system exception</p></li></ul><ul><li><p>基类，其他Controller类继承它</p><p>当一个Controller中有方法加了<code>@ExceptionHandler</code>之后，这个Controller其他方法中没有捕获的异常就会以参数的形式传入加了<code>@ExceptionHandler</code>注解的那个方法中。</p><ul><li><p>设计一个基类，所有需要异常处理的Controller都继承这个类，从而获取到异常处理的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ExceptionHandler</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">expHandler</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> SystemException)&#123;</span><br><span class="line">      <span class="keyword">return</span> String.format(<span class="string">"Error code:%s,Message:%s"</span>, ((SystemException) e).getCode(), e.getMessage());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li><li><p>使用<code>@ControllerAdvice</code>注解做全局异常处理</p><p><code>@ControllerAdvice</code>提供了和前面一样的异常处理能力，但是可以被应用于Spring应用上下文中的所有<code>@Controller</code>，拦截程序抛出的异常。</p><p>Spring MVC默认对于没有捕获也没有被<code>@ResponseStatus</code>以及<code>@ExceptionHandler</code>声明的异常，会直接返回500，这显然并不友好，可以在<code>@ControllerAdvice</code>中对其进行处理</p><ul><li><p>定义全局异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(SystemException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">expHandler</span><span class="params">(SystemException e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResponse(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义统一的JSON返回对象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errcode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JsonResponse</span><span class="params">(<span class="keyword">int</span> errcode, String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errcode = errcode;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JsonResponse(SystemException e)&#123;</span><br><span class="line">        <span class="keyword">this</span>(e.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Controller业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"system exception"</span>,<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"errcode"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"system exception"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li></ul><p><code>优先级问题</code>：</p><p>同一种异常处理在本类的优先级高于全局的异常处理</p><p><code>@RestControllerAdvice</code>:</p><p>@RestControllerAdvice是一个组合注解，组合了@ControllerAdvice、@ResponseBody。</p>]]></content>
      
      
        <tags>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java优先队列 PiorityQueue</title>
      <link href="/2017/10/15/java%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>/2017/10/15/java%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p><code>PriorityQueue</code>是个基于优先级堆的极大优先级队列,PriorityQueue的排序不是普通的排序，而是堆排序。</p><p>排序方式：</p><ul><li>自然排序：根据元素的自然顺序来指定排序(参阅Comparable)，也就是数字默认是小的在队列头，字符串则按字典序排列，也可以根据 Comparator来指定，这取决于使用哪种构造方法。</li><li>定制排序：根据Comparator来指定，使用Comparator类来重写compare(Object o1,Object o2)方法来实现定制排序</li></ul><p>PriorityQueue对元素采用的是堆排序，头是按指定排序方式的最小元素。堆排序只能保证根是最大（最小），整个堆并不是有序的。</p><p>优先级队列不允许null元素，依靠自然排序的优先级队列还不允许插入不可比较的对象(这样做可能导致ClassCastException)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest3</span>   </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue();  </span><br><span class="line">        pq.offer(<span class="number">6</span>);  </span><br><span class="line">        pq.offer(-<span class="number">3</span>);  </span><br><span class="line">        pq.offer(<span class="number">0</span>);  </span><br><span class="line">        pq.offer(<span class="number">9</span>);  </span><br><span class="line">        System.out.println(pq);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序只会保证第一个元素(根节点)的元素是当前优先队列里面最小(或者最大)的元素，而且每一次变化之后，比如offer()或者poll()之后，都会进行堆重排，所以如果想要按从小到大的顺序取出元素，那么需要用一个for循环,如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest3</span>   </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue();  </span><br><span class="line">        pq.offer(<span class="number">6</span>);  </span><br><span class="line">        pq.offer(-<span class="number">3</span>);  </span><br><span class="line">        pq.offer(<span class="number">0</span>);  </span><br><span class="line">        pq.offer(<span class="number">9</span>);  </span><br><span class="line">        <span class="keyword">int</span> len = pq.size();<span class="comment">//这里之所以取出.size()大小，因为每一次poll()之后size大小都会变化，所以不能作为for循环的判断条件  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;  </span><br><span class="line">            System.out.print(pq.poll()+<span class="string">" "</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
